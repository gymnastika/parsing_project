/**
 * Google OAuth Client
 * GYMNASTIKA Management Platform
 * 
 * This module provides Google OAuth 2.0 integration for Gmail API access
 * Handles token management, refresh, and secure storage in Supabase
 */

class GoogleOAuthClient {
    constructor() {
        this.clientId = null;
        this.redirectUri = null;
        this.scopes = [];
        this.isInitialized = false;
        this.supabaseClient = null;
        this.currentUser = null;
        
        // OAuth endpoints
        this.authEndpoint = 'https://accounts.google.com/o/oauth2/v2/auth';
        this.tokenEndpoint = 'https://oauth2.googleapis.com/token';
        this.revokeEndpoint = 'https://oauth2.googleapis.com/revoke';
        
        this.eventListeners = {
            'connected': [],
            'disconnected': [],
            'error': [],
            'token_refreshed': []
        };
    }

    /**
     * Initialize the Google OAuth client
     */
    async initialize(config = null) {
        try {
            console.log('🔑 Initializing Google OAuth client...');
            
            // Load configuration
            const googleConfig = config || window.ENV;
            if (!googleConfig) {
                throw new Error('Google configuration not found');
            }

            this.clientId = googleConfig.GOOGLE_CLIENT_ID;
            this.redirectUri = googleConfig.GOOGLE_REDIRECT_URI || `${window.location.origin}/oauth/callback`;
            this.scopes = googleConfig.GOOGLE_SCOPES || [
                'https://www.googleapis.com/auth/gmail.send',
                'https://www.googleapis.com/auth/userinfo.email',
                'https://www.googleapis.com/auth/userinfo.profile'
            ];

            if (!this.clientId) {
                throw new Error('Google Client ID not configured');
            }

            // Get Supabase client - try multiple sources
            this.supabaseClient = window.gymnastikaDB?.client || window.supabaseClient;
            if (!this.supabaseClient) {
                console.warn('⚠️ Supabase client not available in gymnastikaDB, trying global supabase');
                // Try to get from global supabase if available
                if (typeof supabase !== 'undefined' && window.ENV?.SUPABASE_URL && window.ENV?.SUPABASE_ANON_KEY) {
                    this.supabaseClient = supabase.createClient(
                        window.ENV.SUPABASE_URL,
                        window.ENV.SUPABASE_ANON_KEY
                    );
                    console.log('✅ Created Supabase client for Google OAuth');
                } else {
                    throw new Error('Supabase client not available and cannot create new one');
                }
            }

            this.isInitialized = true;
            console.log('✅ Google OAuth client initialized successfully');

        } catch (error) {
            console.error('❌ Failed to initialize Google OAuth client:', error);
            throw error;
        }
    }

    /**
     * Set current user (required for token operations)
     */
    setCurrentUser(user) {
        this.currentUser = user;
        console.log('👤 Google OAuth client user set:', user?.username);
    }

    /**
     * Check if Google account is connected for current user
     */
    async isConnected() {
        if (!this.currentUser) {
            return false;
        }

        try {
            const integration = await this.getStoredIntegration();
            if (!integration) {
                return false;
            }
            return integration.access_token && new Date(integration.expires_at) > new Date();
        } catch (error) {
            console.error('❌ Error checking Google connection status:', error);
            return false;
        }
    }

    /**
     * Get stored Google integration from Supabase
     */
    async getStoredIntegration() {
        if (!this.currentUser) {
            throw new Error('No current user set');
        }

        try {
            const { data, error } = await this.supabaseClient
                .from('google_integrations')
                .select('*')
                .eq('user_id', this.currentUser.id)
                .maybeSingle();

            if (error) {
                // Handle table not found errors gracefully
                if (error.code === 'PGRST205' || error.message?.includes('Could not find')) {
                    console.warn('⚠️ google_integrations table not found, returning null');
                    return null;
                }
                throw error;
            }

            return data;
        } catch (error) {
            // Handle network/API errors
            if (error.status === 406 || error.status === 404) {
                console.warn('⚠️ Google integrations table not accessible, returning null');
                return null;
            }
            console.error('❌ Error getting stored Google integration:', error);
            return null; // Return null instead of throwing
        }
    }

    /**
     * Initiate Google OAuth authorization flow
     */
    async initiateAuth() {
        if (!this.isInitialized) {
            throw new Error('Google OAuth client not initialized');
        }

        try {
            console.log('🚀 Starting Google OAuth flow...');

            // Generate state parameter for CSRF protection
            const state = this.generateState();
            localStorage.setItem('google_oauth_state', state);

            // Build authorization URL
            const params = new URLSearchParams({
                client_id: this.clientId,
                redirect_uri: this.redirectUri,
                scope: this.scopes.join(' '),
                response_type: 'code',
                state: state,
                access_type: 'offline',
                prompt: 'consent', // Force consent screen to get refresh token
                include_granted_scopes: 'true'
            });

            const authUrl = `${this.authEndpoint}?${params.toString()}`;
            
            console.log('🔗 Opening Google OAuth in popup...');
            
            // Always open in popup for better UX
            const popup = window.open(
                authUrl, 
                'google_oauth', 
                'width=500,height=600,scrollbars=yes,resizable=yes,centerscreen=yes'
            );
            
            if (!popup) {
                throw new Error('Popup blocked. Please allow popups for this site.');
            }
            
            // Set up message listener for callback
            return new Promise((resolve, reject) => {
                let isResolved = false;
                let messageReceived = false;
                
                const cleanup = (interval, timeout, polling) => {
                    if (interval) clearInterval(interval);
                    if (timeout) clearTimeout(timeout);
                    if (polling) clearInterval(polling);
                    window.removeEventListener('message', messageHandler);
                };
                
                const messageHandler = (event) => {
                    console.log('📥 Received message:', {
                        origin: event.origin,
                        expectedOrigin: window.location.origin,
                        dataType: event.data?.type,
                        hasCode: !!event.data?.code,
                        hasState: !!event.data?.state,
                        hasError: !!event.data?.error
                    });
                    
                    // Verify origin for security
                    if (event.origin !== window.location.origin) {
                        console.warn('⚠️ Message from unexpected origin:', event.origin);
                        return;
                    }
                    
                    if (event.data && event.data.type === 'google_oauth_callback') {
                        messageReceived = true;
                        console.log('📨 Received OAuth callback message');
                        
                        // Prevent double processing
                        if (isResolved) {
                            console.log('🔒 OAuth already resolved, ignoring duplicate message');
                            return;
                        }
                        
                        if (event.data.error) {
                            console.error('❌ OAuth error:', event.data.error, event.data.error_description);
                            isResolved = true;
                            cleanup(checkClosedInterval, timeoutId, pollInterval);
                            reject(new Error(event.data.error_description || event.data.error));
                        } else if (event.data.code && event.data.state) {
                            console.log('✅ OAuth success, processing callback...');
                            isResolved = true;
                            cleanup(checkClosedInterval, timeoutId, pollInterval);
                            
                            // Give a small delay to ensure popup has time to show success message
                            setTimeout(() => {
                                this.handleCallback(event.data.code, event.data.state)
                                    .then(resolve)
                                    .catch(reject);
                            }, 500);
                        } else {
                            console.error('❌ Invalid callback data:', event.data);
                            isResolved = true;
                            cleanup(checkClosedInterval, timeoutId, pollInterval);
                            reject(new Error('Invalid callback data received'));
                        }
                    }
                };
                
                // Add message listener with enhanced logging
                console.log('🎧 Adding message listener for OAuth callback');
                window.addEventListener('message', messageHandler);
                
                // Add localStorage polling as fallback with enhanced debugging
                let pollCount = 0;
                console.log('🔄 Starting localStorage polling mechanism...');
                const pollInterval = setInterval(() => {
                    pollCount++;
                    console.log(`🔍 Polling localStorage for OAuth backup (attempt ${pollCount}/60)...`);
                    
                    if (isResolved) {
                        console.log('✅ OAuth resolved, stopping polling');
                        clearInterval(pollInterval);
                        return;
                    }
                    
                    try {
                        const backupData = localStorage.getItem('google_oauth_callback_backup');
                        console.log(`📊 localStorage check result:`, {
                            hasBackupData: !!backupData,
                            dataLength: backupData ? backupData.length : 0,
                            timestamp: new Date().toISOString()
                        });
                        
                        if (backupData) {
                            console.log(`🎯 Found localStorage backup during polling (attempt ${pollCount})`);
                            console.log('📄 Backup data preview:', backupData.substring(0, 200) + '...');
                            
                            try {
                                const parsedData = JSON.parse(backupData);
                                console.log('📋 Parsed backup data:', {
                                    type: parsedData.type,
                                    hasCode: !!parsedData.code,
                                    hasState: !!parsedData.state,
                                    hasError: !!parsedData.error,
                                    backup: parsedData.backup,
                                    savedAt: parsedData.savedAt
                                });
                                
                                localStorage.removeItem('google_oauth_callback_backup');
                                console.log('🗑️ Removed localStorage backup data');
                                
                                if (parsedData.code && parsedData.state && !isResolved) {
                                    console.log('✅ Processing OAuth data from localStorage polling');
                                    isResolved = true;
                                    clearInterval(pollInterval);
                                    cleanup(checkClosedInterval, timeoutId, null);
                                    
                                    this.handleCallback(parsedData.code, parsedData.state)
                                        .then(resolve)
                                        .catch(reject);
                                    return;
                                } else if (parsedData.error && !isResolved) {
                                    console.error('❌ OAuth error found in localStorage:', parsedData.error);
                                    isResolved = true;
                                    clearInterval(pollInterval);
                                    cleanup(checkClosedInterval, timeoutId, null);
                                    reject(new Error(parsedData.error_description || parsedData.error));
                                    return;
                                } else {
                                    console.log('⚠️ Backup data found but invalid or already resolved');
                                }
                            } catch (parseErr) {
                                console.error('❌ Error parsing localStorage backup data:', parseErr);
                                // Remove invalid data
                                localStorage.removeItem('google_oauth_callback_backup');
                            }
                        } else {
                            console.log('📭 No localStorage backup found yet');
                        }
                    } catch (err) {
                        console.error('❌ Error in localStorage polling:', err);
                    }
                    
                    // Stop polling after 3 minutes (more generous timeout)
                    if (pollCount >= 90) {
                        clearInterval(pollInterval);
                        console.log('⏰ Stopped localStorage polling after 3 minutes (90 attempts)');
                    }
                }, 2000); // Check every 2 seconds
                
                // Check if popup was closed manually - wait longer to allow OAuth flow
                let checkCount = 0;
                const checkClosedInterval = setInterval(() => {
                    checkCount++;
                    
                    // Skip first 10 checks to allow OAuth flow to complete (15 seconds)
                    if (checkCount <= 10) {
                        console.log(`⏳ Waiting for OAuth flow completion (check ${checkCount}/10) - OAuth flows typically take 10-15 seconds`);
                        return;
                    }
                    
                    if (popup.closed && !isResolved) {
                        console.log('🔒 Popup closed detected after OAuth flow period');
                        
                        // Check for localStorage backup before giving up
                        console.log('🏪 Checking for localStorage backup...');
                        try {
                            // Wait a bit for callback.html to save data (without await in setInterval)
                            setTimeout(() => {
                                try {
                                    const backupData = localStorage.getItem('google_oauth_callback_backup');
                                    if (backupData) {
                                        console.log('✅ Found localStorage backup, processing...');
                                        const parsedData = JSON.parse(backupData);
                                        localStorage.removeItem('google_oauth_callback_backup');
                                        
                                        if (parsedData.code && parsedData.state && !isResolved) {
                                            isResolved = true;
                                            cleanup(checkClosedInterval, timeoutId, pollInterval);
                                            
                                            this.handleCallback(parsedData.code, parsedData.state)
                                                .then(resolve)
                                                .catch(reject);
                                            return;
                                        }
                                    } else {
                                        console.log('❌ No localStorage backup found');
                                    }
                                } catch (backupErr) {
                                    console.error('❌ Error processing localStorage backup:', backupErr);
                                }
                                
                                // If we reach here and still not resolved, reject
                                if (!isResolved) {
                                    isResolved = true;
                                    cleanup(checkClosedInterval, timeoutId, pollInterval);
                                    reject(new Error('OAuth popup was closed by user'));
                                }
                            }, 1000);
                            
                            return; // Don't continue to the reject below
                            
                        } catch (err) {
                            console.error('❌ Error in backup check setup:', err);
                        }
                        
                        isResolved = true;
                        cleanup(checkClosedInterval, timeoutId, pollInterval);
                        reject(new Error('OAuth popup was closed by user'));
                    }
                }, 1500); // Увеличили интервал до 1.5 секунд
                
                // Timeout after 5 minutes
                const timeoutId = setTimeout(() => {
                    if (!isResolved) {
                        console.log('⏰ OAuth timeout reached');
                        isResolved = true;
                        cleanup(checkClosedInterval, timeoutId, pollInterval);
                        if (!popup.closed) {
                            popup.close();
                        }
                        reject(new Error('OAuth timeout: popup did not respond within 5 minutes'));
                    }
                }, 5 * 60 * 1000);
            });

        } catch (error) {
            console.error('❌ Error initiating Google OAuth:', error);
            this.emit('error', error);
            throw error;
        }
    }

    /**
     * Handle OAuth callback with authorization code
     */
    async handleCallback(code, state) {
        if (!this.isInitialized) {
            throw new Error('Google OAuth client not initialized');
        }

        try {
            console.log('🔄 Handling Google OAuth callback...');

            // Verify state parameter (CSRF protection)
            const storedState = localStorage.getItem('google_oauth_state');
            if (!storedState || storedState !== state) {
                throw new Error('Invalid state parameter - possible CSRF attack');
            }
            localStorage.removeItem('google_oauth_state');

            // Exchange authorization code for tokens
            const tokenData = await this.exchangeCodeForTokens(code);
            
            // Get user profile information
            const profileData = await this.getUserProfile(tokenData.access_token);
            
            // Store the integration
            await this.storeIntegration({
                access_token: tokenData.access_token,
                refresh_token: tokenData.refresh_token,
                expires_at: new Date(Date.now() + (tokenData.expires_in * 1000)).toISOString(),
                scope: tokenData.scope || this.scopes.join(' '),
                connected_email: profileData.email,
                profile_name: profileData.name,
                profile_picture: profileData.picture
            });

            console.log('✅ Google OAuth integration completed successfully');
            this.emit('connected', {
                email: profileData.email,
                name: profileData.name,
                picture: profileData.picture
            });

            return {
                success: true,
                email: profileData.email,
                name: profileData.name
            };

        } catch (error) {
            console.error('❌ Error handling Google OAuth callback:', error);
            this.emit('error', error);
            throw error;
        }
    }

    /**
     * Exchange authorization code for access and refresh tokens
     */
    async exchangeCodeForTokens(code) {
        const response = await fetch(this.tokenEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                client_id: this.clientId,
                client_secret: window.ENV.GOOGLE_CLIENT_SECRET, // This should come from server
                code: code,
                grant_type: 'authorization_code',
                redirect_uri: this.redirectUri
            })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(`Token exchange failed: ${error.error_description || error.error}`);
        }

        return await response.json();
    }

    /**
     * Get user profile from Google API
     */
    async getUserProfile(accessToken) {
        const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
            headers: {
                'Authorization': `Bearer ${accessToken}`
            }
        });

        if (!response.ok) {
            throw new Error('Failed to get user profile from Google');
        }

        return await response.json();
    }

    /**
     * Store integration data in Supabase with retry logic
     */
    async storeIntegration(integrationData, retryCount = 0) {
        const maxRetries = 3;
        const retryDelay = Math.pow(2, retryCount) * 1000; // Exponential backoff: 1s, 2s, 4s
        
        if (!this.currentUser) {
            throw new Error('No current user set');
        }

        try {
            console.log(`💾 Storing Google integration (attempt ${retryCount + 1}/${maxRetries + 1})`);
            
            const { data, error } = await this.supabaseClient
                .from('google_integrations')
                .upsert({
                    user_id: this.currentUser.id,
                    ...integrationData,
                    updated_at: new Date().toISOString()
                }, {
                    onConflict: 'user_id'
                })
                .select()
                .single();

            if (error) {
                throw error;
            }

            console.log('✅ Google integration stored in database successfully');
            return data;

        } catch (error) {
            console.error(`❌ Error storing Google integration (attempt ${retryCount + 1}):`, error);
            
            // Check if this is a retryable error
            const isRetryable = this.isRetryableError(error);
            
            if (isRetryable && retryCount < maxRetries) {
                console.log(`🔄 Retrying database storage in ${retryDelay}ms...`);
                
                await new Promise(resolve => setTimeout(resolve, retryDelay));
                return this.storeIntegration(integrationData, retryCount + 1);
            } else {
                // If max retries reached or non-retryable error, try localStorage backup
                if (retryCount >= maxRetries) {
                    console.log('🏪 Max retries reached, storing to localStorage as backup');
                    try {
                        const backupData = {
                            ...integrationData,
                            user_id: this.currentUser.id,
                            backup: true,
                            failedAt: new Date().toISOString(),
                            error: error.message
                        };
                        localStorage.setItem('google_oauth_integration_backup', JSON.stringify(backupData));
                        console.log('✅ Integration data stored to localStorage backup');
                    } catch (backupError) {
                        console.error('❌ Failed to store backup to localStorage:', backupError);
                    }
                }
                
                throw error;
            }
        }
    }
    
    /**
     * Check if an error is retryable
     */
    isRetryableError(error) {
        // Network errors, temporary database issues, etc.
        const retryableErrors = [
            'NetworkError',
            'TypeError',
            'AbortError',
            'TimeoutError',
            'PGRST001', // Connection lost
            'PGRST301', // Moved Permanently 
            'PGRST302', // Found
            'PGRST503', // Service Unavailable
        ];
        
        const retryableCodes = [408, 429, 502, 503, 504, 520, 521, 522, 523, 524];
        
        return retryableErrors.some(errType => 
            error.name === errType || 
            error.code === errType ||
            error.message.includes(errType)
        ) || retryableCodes.includes(error.status);
    }

    /**
     * Refresh expired access token using refresh token
     */
    async refreshToken() {
        try {
            console.log('🔄 Refreshing Google access token...');

            const integration = await this.getStoredIntegration();
            if (!integration || !integration.refresh_token) {
                throw new Error('No refresh token available');
            }

            const response = await fetch(this.tokenEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    client_id: this.clientId,
                    client_secret: window.ENV.GOOGLE_CLIENT_SECRET,
                    refresh_token: integration.refresh_token,
                    grant_type: 'refresh_token'
                })
            });

            if (!response.ok) {
                const error = await response.json();
                if (error.error === 'invalid_grant') {
                    // Refresh token is invalid, need to re-authenticate
                    await this.disconnect();
                    throw new Error('Refresh token expired, please reconnect your Google account');
                }
                throw new Error(`Token refresh failed: ${error.error_description || error.error}`);
            }

            const tokenData = await response.json();

            // Update stored integration
            await this.storeIntegration({
                ...integration,
                access_token: tokenData.access_token,
                expires_at: new Date(Date.now() + (tokenData.expires_in * 1000)).toISOString(),
                // Keep existing refresh_token if new one not provided
                refresh_token: tokenData.refresh_token || integration.refresh_token
            });

            console.log('✅ Google access token refreshed successfully');
            this.emit('token_refreshed', tokenData);

            return tokenData.access_token;

        } catch (error) {
            console.error('❌ Error refreshing Google token:', error);
            throw error;
        }
    }

    /**
     * Get valid access token (refresh if necessary)
     */
    async getValidAccessToken() {
        try {
            const integration = await this.getStoredIntegration();
            if (!integration) {
                throw new Error('No Google integration found');
            }

            // Check if token is still valid (with 5 minute buffer)
            const expiresAt = new Date(integration.expires_at);
            const now = new Date();
            const bufferTime = 5 * 60 * 1000; // 5 minutes in milliseconds

            if (expiresAt.getTime() - now.getTime() > bufferTime) {
                // Token is still valid
                return integration.access_token;
            }

            // Token needs refresh
            return await this.refreshToken();

        } catch (error) {
            console.error('❌ Error getting valid access token:', error);
            throw error;
        }
    }

    /**
     * Disconnect Google account (revoke tokens and remove from database)
     */
    async disconnect() {
        try {
            console.log('🔌 Disconnecting Google account...');

            const integration = await this.getStoredIntegration();
            if (integration && integration.access_token) {
                // Revoke token at Google
                try {
                    await fetch(`${this.revokeEndpoint}?token=${integration.access_token}`, {
                        method: 'POST'
                    });
                } catch (revokeError) {
                    console.warn('⚠️ Failed to revoke token at Google:', revokeError);
                }
            }

            // Remove from database
            if (integration) {
                const { error } = await this.supabaseClient
                    .from('google_integrations')
                    .delete()
                    .eq('user_id', this.currentUser.id);

                if (error) {
                    throw error;
                }
            }

            console.log('✅ Google account disconnected successfully');
            this.emit('disconnected');

        } catch (error) {
            console.error('❌ Error disconnecting Google account:', error);
            throw error;
        }
    }

    /**
     * Generate secure state parameter for OAuth
     */
    generateState() {
        const array = new Uint8Array(32);
        crypto.getRandomValues(array);
        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    }

    /**
     * Event listener management
     */
    on(event, callback) {
        if (this.eventListeners[event]) {
            this.eventListeners[event].push(callback);
        }
    }

    off(event, callback) {
        if (this.eventListeners[event]) {
            this.eventListeners[event] = this.eventListeners[event].filter(cb => cb !== callback);
        }
    }

    emit(event, data) {
        if (this.eventListeners[event]) {
            this.eventListeners[event].forEach(callback => callback(data));
        }
    }
}

// Export for global use
window.GoogleOAuthClient = GoogleOAuthClient;